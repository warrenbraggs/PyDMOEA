import random
from Genetic import Genetic

class NSGAUtils:

	def __init__(self, problem, n_individuals, n_generations, n_variables, min, max):
		""" NSGAUtils is a class to perform the Non Dominated Sorting mechanism and it contains all the functions, genetic operators required to simulate the algoritm

		Parameters
		----------
		problem : Problem
			MOP/DMOP that is considered
		n_individuals : int
			Number of individuals
		n_generations : int
			Number of iterations performed by the algorithm
		n_variables : int
			Number of variables defined by the specifications of the problem
		min : int
			Minimum value generated by the functions
		max : int
			Maximum value generated by the functions
		"""
		self.problem = problem
		self.n_individuals = n_individuals
		self.n_generations = n_generations
		self.n_variables = n_variables
		self.objective_values = []
		self.min = min
		self.max = max
		self.genetic = Genetic(n_individuals, n_generations, n_variables, min, max)

	
	def isDominated(self, pop1, pop2):
		"""Helper function to determine which population is dominant

		Parameters
		----------
		pop1 : list
			List of individuals
		pop2 : list
			List of individuals

		Returns
		-------
		Boolean
			Dominant population is returned
		"""

		return self.genetic.isDominated(pop1, pop2)


	def generate_random_solutions(self, n):
		""" Generation of random population used for static and dynamic optimisation

		Parameters
		----------
		n : int
			number of individuals generated

		Returns
		-------
		list
			list of individuals (population)
		"""
		return self.genetic.generate_random_solutions(n)
	

	def evaluate_objective_values(self, population, n):
		""" Evaluate the values according to the problem specifications

		Parameters
		----------
		population : list
			List of individuals
		n : int
			number of objects to evaluate

		Returns
		-------
		list
			List of all the objective values from the population
		"""
		for i in range(n):		
			f1, f2 = self.problem.evaluate_objective_values(population[i])
			self.objective_values.append([f1, f2])
		return self.objective_values
	

	def calculate_objective_values(self, population, n):
		""" Calculate the objective value according to the problem specifications

		Parameters
		----------
		population : list
			List of individuals
		n : int
			Number of objects to be evaluated

		Returns
		-------
		list
			Objective value of the individual
		"""		
		temp_obj = []
		for i in range(n):		
			f1, f2 = self.problem.evaluate_objective_values(population[i])
			temp_obj.append([f1,f2])
		return temp_obj
	

	def replace_element(self, population:list, new_element, n):
		""" Replace individuals with new random elements

		Parameters
		----------
		population : list
			List of individuals
		new_element : list
			List of new random solutions
		n : int
			number of solutions to be replaced

		Returns
		-------
		list
			New list of individuals
		"""		
		for i in range(n):
			r = random.randrange(len(population))
			population.pop(r)
			population.append(new_element[i])

		return population


	def replace_child(self, population:list, children, n):
		""" Replace selected individuals with random mutated solutions

		Parameters
		----------
		population : list
			List of individuals
		children : list
			List of individuals
		n : int
			number of solutions to be replaced

		Returns
		-------
		list
			New population with mutated solutions
		"""
		for i in range(n):
			child = random.choice(population)
			index_child = population.index(child)
			population.pop(index_child)
			population.append(random.choice(children))
		return population	


	def fast_non_dominated_sort(self, population:list):
		""" Determination the Optimal set of solutions as part of the NSGAII Algorithm

		Code adapted from: https://github.com/baopng/NSGA-II/blob/master/nsga2/utils.py

		Parameters
		----------
		population : list
			List of individuals

		Returns
		-------
		list
			Pareto Optimal Front
		"""
		dominated_solutions = [0] * len(population)	# Dominated solutions S
		count = [0] * len(population)	# domination counter n
		pareto_front = [[]]	# pareto optimal front
		rank = [0] * len(population)	# rank for the pareto optimal front

		for p in range(len(population)):
			dominated_solutions[p] = []	
			count[p] = 0

			for q in range(p+1, len(population)):
				# Check the dominaiton between two individuals
				if self.isDominated(self.objective_values[p], self.objective_values[q]):
					if self.objective_values[q] not in dominated_solutions[p]:
						# Update the list of dominated solutions with the second individual
						dominated_solutions[p].append(self.objective_values[q])
				elif self.isDominated(self.objective_values[q], self.objective_values[p]):
					# Increase the dominaiton counter
					count[p] = count[p] + 1

			# If no other domination is found, the individual is dominant and it is added to the pareto front
			if count[p] == 0:				
				rank[p] = 0     
				pareto_front[0].append(self.objective_values[p])

		# Sort the rest of the solutions and add them to the pareto front
		i = 0
		while len(pareto_front[i]) > 0:
			store_temp_fronts = []		
			for p in range(len(pareto_front[i])):
				for q in range(0, len(dominated_solutions)):
					count[q] = count[q] - 1 
					if count[q] == 0:
						rank[q] = i + 1
						# Temporal pool of pareto fronts
						store_temp_fronts.append(self.objective_values[q])

			# Update the pareto optimal front
			pareto_front.append(store_temp_fronts)
			i = i + 1

		# Return the optimal fronts
		return pareto_front


	def crowding_distance(self, pareto_front):
		""" Determine the crowding distance between the individuals obtained by the Fast Non Dominated Sort

		Code adapted from: https://github.com/baopng/NSGA-II/blob/master/nsga2/utils.py

		Parameters
		----------
		pareto_front : list
			Set of optimal solutions

		Returns
		-------
		list
			List of distances of the individuals
		"""
		if len(pareto_front) > 0:	
			distance = [0 for i in range(0,len(pareto_front))]

			for j in range(len(pareto_front)):
				try:
					# Sort the pareto optimal front in ascending order
					pareto_front[j].sort()
					# The first and last elements are assigned with large random number
					distance[0] = 123456789
					distance[len(pareto_front)-1] = 123456789

					# Calculate the crowding distance of the individual
					for i in range(1,len(pareto_front)-1):
						distance[i] = distance[i]+ (pareto_front[i+1][0] - pareto_front[i-1][0])/(max(pareto_front[i])-min(pareto_front[i]))
				except:
					return						

			# Return the list of distances for the individuals
			return distance
		
	 
	def tournament_selection(self, population):		
		""" Function to determine the dominant solutions that will be chosen for performing genetic operations	

		Parameters
		----------
		population : list
			List of individuals

		Returns
		-------
		list	
			Dominant individual among the pool of individuals
		"""		
		tournament_size = self.n_variables	# randomly chosen
		tournament = []
		best_individual = []

		# Iterate over the tournament of solutions
		for j in range(tournament_size):
			# Choose a random solution from the pool
			individual = random.choice(population)
			# Add the solution to the tournament list
			tournament.append(individual)

		# Determine the solution used for the next operations
		best_individual.append(self.get_best(tournament))		
		
		# Return the individual
		return best_individual
	

	def get_best(self, population):
		""" Helper function to determine the best individual

		Parameters
		----------
		population : list
			List of individuals

		Returns
		-------
		list
			Best individual according to the parameters
		"""
		return self.genetic.get_best(population)


	def sbx(self, parent1, parent2, n_c):
		""" Simulated Binary Crossver function

		Code adapted from: https://github.com/DEAP/deap/blob/master/deap/tools/crossover.py

		Parameters
		----------
		parent1 : list
			List of 2 elements containing the x,y generated by the objective function
		parent2 : list
			List of 2 elements containing the x,y generated by the objective function
		n_c : int
			Distribution index used for the crossover operation

		Returns
		-------
		list
			List of 2 individuals generated
		"""
		return self.genetic.sbx(parent1, parent2, n_c)
	

	def polynomial_mutation(self, population, eta):
		""" Polynomial mutation for the selected solutions

		Parameters
		----------
		population : list
			List of individuals
		eta : int
			Mutation Probability index

		Returns
		-------
		list
			List of individuals mutated
		"""

		return self.genetic.polynomial_mutation(population, eta)
	

	def create_child(self, population):
		""" Create children based on the individuals given

		Parameters
		----------
		population : list
			List of individuals

		Returns
		-------
		list
			List of individuals generated by the SBX and Polynomial Mutation
		"""
		child = []
		n_c = 100
		eta = 100		

		while len(child) < len(population):
			# Select the individuals that will be used for the next operations 
			parent1 = self.tournament_selection(population)
			
			while (parent1[0][1] is None): 
				parent1 = self.tournament_selection(population)
			parent2 = parent1

			# Check if the individuals chosen are the same. In case, another individual is found
			while parent1 == parent2:
				parent2 = self.tournament_selection(population)
				while (parent2[0][1] is None): 
					parent2 = self.tournament_selection(population)		


			# Perform the crossover operation
			temp_child = self.sbx(parent1[0], parent2[0], n_c)
			# Perform the mutation operation
			temp_child[0] = self.polynomial_mutation(temp_child[0], eta)
			temp_child[1] = self.polynomial_mutation(temp_child[1], eta)

			# Calculate the objective values of the individuals generated
			self.evaluate_objective_values(temp_child,len(temp_child))

			child.append(temp_child)
		
		# Return the child created
		return child
	
	



class COEAUtils:

	def __init__(self, problem, n_individuals, n_generations, n_variables, min, max):
		"""COEAUtils is a class to perform the Cooperative Competitive Coevolutionary Mechanism 
		and it contains all the functions, genetic operators required to simulate the algorithm

		Parameters
		----------
		problem : Problem
			MOP/DMOP that is considered
		n_individuals : int
			Number of individuals
		n_generations : int
			Nubmer of iterations performed by the algorithm
		n_variables : int
			Number of variables defined by the specifications of the problem
		min : int
			Minimum value generated by the functions
		max : int
			Maximum value generated by the functions
		"""
		self.problem = problem
		self.n_individuals = n_individuals
		self.n_generations = n_generations
		self.n_variables = n_variables
		self.objective_values = []
		self.min = min
		self.max = max
		self.archive = []
		self.genetic = Genetic(n_individuals, n_generations, n_variables, min, max)


	def generate_random_solutions(self, n):
		""" Generation of random population used for static and dynamic optimisation

		Parameters
		----------
		n : int
			number of individuals generated

		Returns
		-------
		list
			list of individuals (population)
		"""
		return self.genetic.generate_random_solutions(n)
	

	def evaluate_objective_values(self, population, n):
		""" Evaluate the values according to the problem specifications

		Parameters
		----------
		population : list
			List of individuals
		n : int
			number of objects to evaluate

		Returns
		-------
		list
			List of all the objective values from the population
		"""
		for i in range(n):		
			f1, f2 = self.problem.evaluate_objective_values(population[i])
			self.objective_values.append([f1, f2])
		return self.objective_values
	

	def calculate_objective_values(self, population, n):
		""" Calculate the objective value according to the problem specifications

		Parameters
		----------
		population : list
			List of individuals
		n : int
			Number of objects to be evaluated

		Returns
		-------
		list
			Objective value of the individual
		"""		
		temp_obj = []
		for i in range(n):		
			f1, f2 = self.problem.evaluate_objective_values(population[i])
			temp_obj.append([f1,f2])
		return temp_obj

	
	def get_objective_values(self):
		""" Get the objective value

		Returns
		-------
		list
			Objective value
		"""
		return self.objective_values
	

	def tournament_selection(self, population):		
		""" Function to determine the dominant solutions that will be chosen for performing genetic operations	

		Parameters
		----------
		population : list
			List of individuals

		Returns
		-------
		list	
			Dominant individual among the pool of individuals
		"""		
		tournament_size = 5	# randomly chosen
		tournament = []
		best_individual = []

		# Iterate over the tournament of solutions
		for j in range(tournament_size):
			# Choose a random solution from the pool
			individual = random.choice(population)
			# Add the solution to the tournament list
			tournament.append(individual)
		
		# Determine the solution used for the next operations
		best_individual.append(self.get_best(tournament))

		# Return the individual
		return best_individual
	

	def get_best(self, population):
		""" Helper function to determine the best individual

		Parameters
		----------
		population : list
			List of individuals

		Returns
		-------
		list
			Best individual according to the parameters
		"""
		return self.genetic.get_best(population)


	def get_worst(self, population):
		""" Helper function to determine the worst individual

		Parameters
		----------
		population : list
			List of individuals

		Returns
		-------
		list
			Worst individual from the pool of solutions 
		"""
		worst = population[0][0]
		
		for i in range(1,len(population)):
			if population[i][0] < worst:
				worst = population[i][0]

		return worst

	
	def sbx(self, parent1, parent2, n_c):
		""" Simulated Binary Crossver function

		Code adapted from: https://github.com/DEAP/deap/blob/master/deap/tools/crossover.py

		Parameters
		----------
		parent1 : list
			List of 2 elements containing the x,y generated by the objective function
		parent2 : list
			List of 2 elements containing the x,y generated by the objective function
		n_c : int
			Distribution index used for the crossover operation

		Returns
		-------
		list
			List of 2 individuals generated
		"""
		return self.genetic.sbx(parent1, parent2, n_c)
	

	def polynomial_mutation(self, population, eta):
		""" Polynomial mutation for the selected solutions

		Parameters
		----------
		population : list
			List of individuals
		eta : int
			Mutation Probability index

		Returns
		-------
		list
			List of individuals mutated
		"""

		return self.genetic.polynomial_mutation(population, eta)
	

	def create_child(self, population):
		""" Create children based on the individuals given

		Parameters
		----------
		population : list
			List of individuals

		Returns
		-------
		list
			List of individuals generated by the SBX and Polynomial Mutation
		"""
		n_c = 100 # crossover rate
		eta = 100 # mutation rate

		# Dermine the first parent using the Tournament selection 
		parent1 = self.tournament_selection(population)
		parent2 = parent1

		# If parent1 and parent2 are the same, determine the parent 2 again with the Tournament selection
		while parent1 == parent2:
			parent2 = self.tournament_selection(population)
		
		try:
			# Crossover
			temp_child = self.sbx(parent1[0], parent2[0], n_c)
			# Mutation
			temp_child[0] = self.polynomial_mutation(temp_child[0], eta)
			temp_child[1] = self.polynomial_mutation(temp_child[1], eta)


			# Calculate the objective values of the individuals generated
			child = self.calculate_objective_values(temp_child,len(temp_child))
		except:
			return
		
		# Return the child created
		return child


	def get_fitness(self):
		""" Return the fitness/number of generations

		Returns
		-------
		int
			Number of generations
		"""
		return self.n_generations
	
	
	def split_populations(self, population, n):
		""" Helper function to create sub-populations given the size n

		Parameters
		----------
		population : list
			List of individuals
		n : int
			Number of splits

		Returns
		-------
		list
			Equally sized sub-populations
		"""
		return list(population[i::n] for i in range(n))
	

	def cooperative_process(self, population:list):
		""" Implementation of the Cooperative mechanism for performing the COEA

		Parameters
		----------
		population : list
			List of individuals (subpopulations)

		Returns
		-------
		list
			Set of optimal solutions
		"""	
		solution = []

		# Length of the subpopulation
		length_population = len(population)
		n_elements = len(population[-1])

		index = random.randint(0, n_elements-1)
		for i in range(length_population):
			# Set up a complete solution by using individuals from other subpopulations
			solution.append(population[i][index])
		
		# Calculation of the objective values in accordance to the definition of the MOP/DMOP
		solution = self.calculate_objective_values(solution, len(solution))

		# Update Archive
		self.archive.extend(solution)

		#Return the solution
		return solution


	def competitive_process(self, population:list):
		""" Implementation of the Competitive mechanism for performing the COEA

		Parameters
		----------
		population : list
			List of individuals (subpopulation)

		Returns
		-------
		list
			Set of optimal solutions
		"""		

		# Define the competition pool as an empty list
		competition_pool = []

		# Length of the subpopulation
		length_population = len(population)
		n_elements = len(population[-1])
		
		
		for i in range(length_population):
			# Insert the representative of the subpopulation in the competition pool. In this case the representative is a random index
			index = random.randint(0, n_elements-1)
			competition_pool.append(population[i][index])
			

			if length_population > len(population[i]):
				# Select competing subpopulations randomly
				index = random.randint(0, n_elements-1)
				# Insert competitors in the pool
				competition_pool.append(population[i][index])
			elif length_population <= len(population[i]):
				# Select other competitors
				elem = random.choice(population)
				index = random.randint(0, n_elements-1)
				# Insert competitors to the pool
				competition_pool.extend([elem[index]])

		# Return the set of competitive solutions
		return competition_pool
	

	def temporal_archive_update(self, population:list):
		""" Temporal Archive Update mechanism used for DCOEAB

		Parameters
		----------
		population : list
			List of individuals

		Returns
		-------
		list
			Update pool of solutions
		"""

		# r_size representes the size of the archive
		r_size = len(self.archive)
		# M is the size of the population considered
		M = len(population)
		# archive_limit is the maximum size of the archive
		archive_limit = len(self.archive)

		# Temporary pool representing the archive
		p = []
		newArchive = []

		# Select and remove the best archived solution from A and added to p		
		best = self.get_best(self.archive)
		self.archive.remove(best)
		p.append(best)


		if r_size >= M:
			# Add the solution of the temporary pool to the new archive
			newArchive.append(p)
			# Randomly select and remove an element from the archive A
			elem = random.choice(self.archive)
			self.archive.remove(elem)
			newArchive.append(elem)

		else:
			# Randomly select and remove an element from the archive p
			elem = random.choice(p)
			p.remove(elem)
			newArchive.append(elem)
		
		# Remove the oldest solutions which is the worst 
		if len(newArchive) > archive_limit:
			worst = self.get_worst(newArchive)
			newArchive.remove(worst)

		# Return the new archive
		return newArchive
